## **关键字与运算符**

#### **指针与引用**

> **指针**存放某个对象的地址，其本⾝就是**变量**（命了名的对象），本⾝就有地址，所以可以有指向指针的指针；可变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变 
>
> **引⽤**就是变量的别名，从⼀⽽终，**不可变**，**必须初始化** 
>
> **不存在指向空值的引⽤，但是存在指向空值的指针**

**在使用引用的过程中，要注意以下几点：**

1. &在这里不再是取地址符号，而是引用符号
2. 引用的类型需要和其绑定的变量的类型相同（目前这样使用，学习继承后这一条有所不同）
3. <font color=red>**声明引用的同时，必须对引用进行初始化，否则编译时报错**</font>
4. <span style=color:red;background:yellow>**引用一经绑定，无法更改绑定**</span>

##### ==**引用与指针的联系与区别**==

> 这是一道非常经典的面试题，请尝试着回答一下：
>
> 联系：
>
> 1. 引用和指针都有地址的概念，都是用来间接访问变量；
>
> 2. 引用的底层还是指针来完成，可以把引用视为一个受限制的指针。（const pointer）
>
> 区别：
>
> 1. 引用必须初始化，指针可以不初始化；
> 2. 引用不能修改绑定，但是指针可以修改指向；
> 3. 在代码层面对引用本身取址取到的是变量的地址，但是对指针取址取到的是指针变量本身的地址

#### const关键字

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

> const作用:被它修饰的值不能改变，是只读变量。必须在定义的时候给其赋初始值

###### 指向常量的指针

（pointer to const)

- const 数据类型 *指针变量 = 变量名
- 数据类型 const *指针变量 = 变量名

> 是指定义了⼀个指针，这个指针指向⼀个**只读**的对象，不能通过常量指针来改变这个对象的值。
>
> ==强调的是指针对其所指对象的不可改变性 但是可以改变这个指针的指向==

###### 常量指针

(const pointer）自身是常量的指针

- 数据类型 * const 指针变量 = 变量名

> const在*右边，即为常量指针，不能改变这个指针的指向，但是可以通过指针改变其指向的值。
>
> ==强调的是指针的不可改变性==

```C++

// 类
class A
{
private:
    const int a;                // 常对象成员，可以使用初始化列表或者类内初始化

public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function()
{
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 指针变量，指向常对象
    const A &q = a;             // 指向常对象的引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常量
void function4(const int& Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();

```

#### 宏定义 #define 和 const 常量

| 宏定义 #define         | const 常量     |
| ---------------------- | -------------- |
| 宏定义，相当于字符替换 | 常量声明       |
| 预处理器处理           | 编译器处理     |
| 无类型安全检查         | 有类型安全检查 |
| 不分配内存             | 要分配内存     |
| 存储在代码段           | 存储在数据段   |
| 可通过 `#undef` 取消   | 不可取消       |